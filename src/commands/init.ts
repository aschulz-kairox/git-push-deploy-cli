import chalk from 'chalk';
import { getServiceConfig, findConfigFile } from '../config/loader.js';
import { getServers, type ServerConfig } from '../config/types.js';
import { sshExec, checkSshConnection, findSshPublicKey, copySshKey, checkSshKeyPermissions } from '../utils/shell.js';
import * as readline from 'readline';

interface InitOptions {
  skipSshCheck?: boolean;
  quiet?: boolean;  // For auto-init during deploy
}

/**
 * Prompt user for yes/no confirmation
 */
async function confirm(question: string): Promise<boolean> {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  
  return new Promise((resolve) => {
    rl.question(`${question} (y/n): `, (answer) => {
      rl.close();
      resolve(answer.toLowerCase() === 'y' || answer.toLowerCase() === 'yes');
    });
  });
}

/**
 * Check SSH connection and offer to copy key if needed
 * Returns true if connection is ready, false if user aborted
 */
async function ensureSshConnection(host: string, sshOptions?: string): Promise<boolean> {
  console.log(chalk.blue('Checking SSH connection...'));
  
  // Test connection
  if (checkSshConnection(host, sshOptions)) {
    console.log(chalk.green('  ✓ SSH key authentication working'));
    return true;
  }
  
  console.log(chalk.yellow('  ⚠ SSH key authentication not working'));
  
  // Find local public key
  const keyPath = findSshPublicKey();
  if (!keyPath) {
    console.log(chalk.red('  ✗ No SSH public key found (~/.ssh/id_*.pub)'));
    console.log(chalk.gray('    Generate one with: ssh-keygen -t ed25519'));
    return false;
  }
  
  console.log(chalk.gray(`  Found key: ${keyPath}`));
  
  // Check private key permissions (security warning if too open)
  checkSshKeyPermissions(keyPath);
  
  // Offer to copy key
  const shouldCopy = await confirm('  Copy SSH key to server?');
  if (!shouldCopy) {
    console.log(chalk.yellow('  Skipping SSH key setup. You may need to enter password for each command.'));
    return true; // Continue anyway
  }
  
  console.log(chalk.blue('  Copying SSH key...'));
  try {
    copySshKey(host, keyPath, sshOptions);
    console.log(chalk.green('  ✓ SSH key copied'));
    
    // Verify it works now
    if (checkSshConnection(host, sshOptions)) {
      console.log(chalk.green('  ✓ SSH key authentication now working'));
      return true;
    } else {
      console.log(chalk.yellow('  ⚠ SSH still requires password. Check server configuration.'));
      return true; // Continue anyway
    }
  } catch (error) {
    console.log(chalk.red(`  ✗ Failed to copy SSH key: ${error}`));
    return false;
  }
}

/**
 * Generate post-receive hook content
 * The hook simply calls `gpd install <service>` which handles all the logic
 */
function generatePostReceiveHook(serviceName: string, config: {
  targetDir: string;
  bareRepo: string;
  pm2User?: string;
  pm2Home?: string;
}): string {
  const { targetDir, bareRepo, pm2User, pm2Home } = config;
  
  // Build the install command - pass env vars explicitly with sudo
  let installCmd: string;
  const configPath = `${targetDir}/.git-deploy.json`;
  
  if (pm2User) {
    // sudo -E doesn't work reliably, so we pass vars explicitly
    // GPD_PM2_USER tells install.ts which user context we're running as
    const envVars = [
      `GPD_TARGET_DIR="${targetDir}"`,
      `GPD_GIT_DIR="${bareRepo}"`,
      `GPD_SERVICE="${serviceName}"`,
      `GPD_PM2_USER="${pm2User}"`,
    ];
    if (pm2Home) {
      envVars.push(`PM2_HOME="${pm2Home}"`);
    }
    installCmd = `sudo -u ${pm2User} ${envVars.join(' ')} gpd install ${serviceName} -c ${configPath}`;
  } else {
    installCmd = `gpd install ${serviceName} -c ${configPath}`;
  }
  
  return `#!/bin/bash
set -e

# GPD post-receive hook for ${serviceName}
# Generated by: gpd init ${serviceName}

SERVICE="${serviceName}"
TARGET_DIR="${targetDir}"
GIT_DIR="${bareRepo}"
LOG_FILE="/var/log/gpd-${serviceName}.log"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

log "=== Deployment started for $SERVICE ==="

while read oldrev newrev refname; do
    BRANCH=$(echo "$refname" | sed 's|refs/heads/||')
    log "Received push to branch: $BRANCH"
    
    if [ "$BRANCH" != "main" ] && [ "$BRANCH" != "master" ]; then
        log "Ignoring branch $BRANCH (only main/master triggers deploy)"
        continue
    fi

    # Export variables for gpd install (used when not using sudo)
    export GPD_TARGET_DIR="$TARGET_DIR"
    export GPD_GIT_DIR="$GIT_DIR"
    export GPD_SERVICE="$SERVICE"
    ${pm2Home ? `export PM2_HOME="${pm2Home}"` : ''}

    # Run gpd install (handles checkout, npm install, pm2 restart)
    log "Running: ${installCmd}"
    ${installCmd} 2>&1 | tee -a "$LOG_FILE"
done

log "=== Deployment completed ==="
`;
}

/**
 * Check if a server is already initialized (bare repo exists)
 */
function checkServerInitialized(host: string, bareRepo: string, sshOptions?: string): boolean {
  try {
    // Check if bare repo exists and is a git repo
    sshExec(host, `test -d "${bareRepo}/objects"`, { sshOptions, silent: true });
    return true;
  } catch {
    return false;
  }
}

/**
 * Ensure all servers for a service are initialized
 * Called automatically by deploy command - idempotent operation
 */
export async function ensureInitialized(serviceName: string): Promise<void> {
  const config = getServiceConfig(serviceName);
  const servers = getServers(config);
  
  for (const server of servers) {
    const isInitialized = checkServerInitialized(server.host, server.bareRepo, server.sshOptions);
    
    if (!isInitialized) {
      console.log(chalk.yellow(`  Server ${server.host} not initialized, running init...`));
      await initServer(serviceName, server, config, { skipSshCheck: false, quiet: false });
    }
  }
}

/**
 * Init command - initialize bare repo and target directory on remote server via SSH
 * 
 * Creates:
 * 1. Bare repo at server.bareRepo (e.g., /git/sym/deploy-kairox/staging/kairox-api)
 * 2. Target directory at server.targetDir (e.g., /opt/kairox/staging/kairox-api)
 * 3. Post-receive hook that calls `gpd install <service>`
 */
export async function initCommand(serviceName: string, _options: InitOptions = {}): Promise<void> {
  console.log(chalk.blue(`Initializing ${serviceName}...`));
  
  const config = getServiceConfig(serviceName);
  const servers = getServers(config);
  const { pm2User, pm2Home } = config;
  
  console.log(chalk.gray(`  Servers: ${servers.length}`));
  if (pm2User) console.log(chalk.gray(`  PM2 user: ${pm2User}`));
  console.log('');
  
  // Initialize each server
  for (const server of servers) {
    await initServer(serviceName, server, config, _options);
    if (servers.length > 1) console.log('');
  }
  
  console.log(chalk.green(`✓ Initialized ${serviceName} on ${servers.length} server(s)`));
  console.log('');
  console.log(chalk.gray('Server setup complete. Now you can deploy:'));
  console.log(chalk.white(`  gpd deploy ${serviceName}`));
}

/**
 * Initialize a single server
 */
async function initServer(
  serviceName: string, 
  server: ServerConfig,
  config: { pm2User?: string; pm2Home?: string },
  options: InitOptions
): Promise<void> {
  const { host, bareRepo, targetDir, sshOptions, group } = server;
  const { pm2User, pm2Home } = config;
  const serverLabel = server.name || host;
  
  console.log(chalk.blue(`  Setting up ${serverLabel}...`));
  console.log(chalk.gray(`    Host: ${host}`));
  console.log(chalk.gray(`    Bare repo: ${bareRepo}`));
  console.log(chalk.gray(`    Target dir: ${targetDir}`));
  if (group) console.log(chalk.gray(`    Group: ${group}`));
  
  // 0. Check SSH connection first
  if (!options.skipSshCheck) {
    const sshReady = await ensureSshConnection(host, sshOptions);
    if (!sshReady) {
      console.log(chalk.red(`  Skipping ${serverLabel} - SSH connection failed`));
      return;
    }
  }
  
  // 1. Create group if specified
  if (group) {
    console.log(chalk.gray(`    Creating group ${group}...`));
    const createGroupCmd = `sudo groupadd -f ${group} && sudo usermod -aG ${group} $(whoami)`;
    sshExec(host, createGroupCmd, { sshOptions });
  }
  
  // 2. Create bare repo with shared group access
  console.log(chalk.gray(`    Creating bare repo...`));
  const bareRepoParent = bareRepo.split('/').slice(0, -1).join('/');
  let createBareCmd = `sudo mkdir -p ${bareRepoParent}`;
  if (group) {
    createBareCmd += ` && sudo chgrp ${group} ${bareRepoParent} && sudo chmod g+rwxs ${bareRepoParent}`;
  }
  createBareCmd += ` && cd ${bareRepoParent} && git init --bare --shared=group ${bareRepo.split('/').pop()}`;
  if (group) {
    createBareCmd += ` && sudo chgrp -R ${group} ${bareRepo}`;
  }
  sshExec(host, createBareCmd, { sshOptions });
  
  // 3. Create target directory
  console.log(chalk.gray(`    Creating target directory...`));
  const targetParent = targetDir.split('/').slice(0, -1).join('/');
  let createTargetCmd = `sudo mkdir -p ${targetDir}`;
  if (pm2User) {
    createTargetCmd += ` && sudo chown ${pm2User}:${group || pm2User} ${targetDir}`;
  }
  if (group) {
    createTargetCmd += ` && sudo chgrp -R ${group} ${targetParent} && sudo chmod g+rwxs ${targetParent}`;
  }
  sshExec(host, createTargetCmd, { sshOptions });
  
  // 4. Create post-receive hook
  console.log(chalk.gray(`    Creating post-receive hook...`));
  const hookContent = generatePostReceiveHook(serviceName, {
    targetDir,
    bareRepo,
    pm2User,
    pm2Home
  });
  
  // Escape for shell (use base64 to avoid quote issues)
  const hookBase64 = Buffer.from(hookContent).toString('base64');
  const hookPath = `${bareRepo}/hooks/post-receive`;
  const createHookCmd = `echo '${hookBase64}' | base64 -d | sudo tee ${hookPath} > /dev/null && sudo chmod +x ${hookPath}`;
  if (group) {
    sshExec(host, `${createHookCmd} && sudo chgrp ${group} ${hookPath}`, { sshOptions });
  } else {
    sshExec(host, createHookCmd, { sshOptions });
  }
  
  // 5. Create log file
  console.log(chalk.gray(`    Creating log file...`));
  const logFile = `/var/log/gpd-${serviceName}.log`;
  let createLogCmd = `sudo touch ${logFile} && sudo chmod 666 ${logFile}`;
  if (group) {
    createLogCmd += ` && sudo chgrp ${group} ${logFile}`;
  }
  sshExec(host, createLogCmd, { sshOptions });
  
  console.log(chalk.green(`  ✓ Initialized on ${serverLabel}`));
}
